<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Unidad 2</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css">
</head>

<body>
  <section>
    <nav class="navbar has-shadow" role="navigation" aria-label="main navigation">
      <div class="navbar-brand">


        <a role="button" class="navbar-burger" aria-label="menu" aria-expanded="false" data-target="navbarBasicExample"
          id="burger">
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
        </a>
      </div>

      <div id="navbarBasicExample" class="navbar-menu">
        <div class="navbar-start">
          <a class="navbar-item " href="index.html">
            Inicio
          </a>

          <div class="navbar-item has-dropdown is-hoverable has-text-grey">
            <a class="navbar-link">
              Unidades
            </a>
            <div class="navbar-dropdown">
              <a class="navbar-item" href="unidad1.html">
                Unidad 1
              </a>
              <a class="navbar-item" href="unidad2.html">
                Unidad 2
              </a>
              <a class="navbar-item" href="unidad3.html">
                Unidad 3
              </a>
              <a class="navbar-item" href="unidad4.html">
                Unidad 4
              </a>
            </div>
          </div>

          <div class="navbar-item has-dropdown is-hoverable">
            <a class="navbar-link">
              Prácticas
            </a>
            <div class="navbar-dropdown">
              <a class="navbar-item" href="/docs/JDHG - PRÁCTICA 1.pdf" target="_blank">
                Práctica 1
              </a>
              <a class="navbar-item" href="/docs/JDHG - PRÁCTICA 2.pdf" target="_blank">
                Práctica 2
              </a>
              <a class="navbar-item" href="/docs/JDHG - PRÁCTICA 3.pdf" target="_blank">
                Práctica 3
              </a>
              <a class="navbar-item" href="/docs/JDHG - PRÁCTICA 4.pdf" target="_blank">
                Práctica 4
              </a>
            </div>
          </div>
        </div>

        <div class="navbar-end">
          <div class="navbar-item">
            <div class="buttons">
              <a class="button is-dark" href="https://github.com/wrongcowboy" target="_blank">
                <strong>Github</strong>
              </a>
              <a class="button is-info" href="https://saltillo.tecnm.mx/" target="_blank">
                <strong>Sitio ITS</strong>
              </a>
            </div>
          </div>
        </div>
      </div>
    </nav>
  </section>

  <section class="is-medium">

    <div class="container has-shadow has-text-centered py-1">
      <h3 class="title is-3">Unidad 2. Estructura y funcionamiento de CPU</h3>
      <h5 class="subtitle is-5 has-text-left">2.1 Organización del procesador</h5>
      <p class="has has-text-justified">
        La función principal es ejecutar instrucciones, la organización viene condicionada por las
        tareas que debe realizar y por cómo debe hacerlo operan según una señal de
        sincronización conocida como señal de reloj.</p>
      <p class="has-text-justified py-2">
        Incluye tantos registros visibles para el usuario todo procesador dispone de 3
        componentes.
      </p>

      <p class="has-text-justified py-2">
        <strong>UAL:</strong> circuito que hace un conjunto de operaciones aritméticas lógicas con los datos
        almacenados dentro del procesador.
      </p>
      <p class="has-text-justified py-2">
        <strong>Conjunto de registros:</strong> circuito que hace un conjunto de operaciones aritméticas lógicas con los
        datos
        almacenados dentro del procesador.
      </p>
      <p class="has-text-justified py-2">
        Dentro del procesador.
      </p>
      <p class="has-text-justified py-2">
        <strong>Unidad de control:</strong> circuito que controla el funcionamiento de todos los componentes del
        procesador.
      </p>
      <p class="has-text-justified py-2">
        Controla el movimiento de datos e instrucciones dentro y fuera del procesador y también
        las operaciones ALU.
      </p>
      <h5 class="subtitle is-5 has-text-left">
        2.2 Estructura de Registros
      </h5>
      <p class="has-text-justified py-2">
        Se emplean para controlar las instrucciones en ejecución, manejar direccionamiento de
        memoria y propiciar la capacidad aritmética</p>

      <p class="has-text-justified py-2">
        <strong> Registro de datos:</strong> Un CPU puede funcionar con datos en uno de tres modos: entre dos
        registros, entre registros y una ubicación de Memoria de acceso al azar (RAM - RandomAccess Memory) y entre dos
        ubicaciones RAM. Como el CPU está conectado
        directamente a los registros, las operaciones que implican dos registros son las más
        rápidas; las que se dan entre ubicaciones RAM son las más lentas. Es decir, junta dos
        registros, añade un registro a una ubicación RAM, o añade dos ubicaciones RAM.
      </p>

      <p class="has-text-justified py-2">
        <strong> Registro de direcciones:</strong> Para que un CPU pueda almacenar y recuperar datos en RAM,
        debe tener la dirección de la memoria de la información. Esas operaciones que implican
        RAM usan registros de dirección de memoria. EL CPU no realiza aritmética en estos
        registros; en cambio, los usa para ubicar datos que necesita.
      </p>

      <p class="has-text-justified py-2">
        <strong> Registro de índice:</strong> Un CPU no puede hacer matemáticas en registros de datos, aunque
        puede hacerlo indirectamente con un registro de índice. Éste trabaja con los registros de
        datos, permitiendo a un programa procesar hilos de información eficazmente.
      </p>

      <p class="has-text-justified py-2">
        <strong> Registro de segmento:</strong> Un registro de segmento tiene 16 bits de longitud y facilita un
        área de memoria para direccionamiento conocida como segmento actual.
      </p>
      <p class="py-1">
      <ul>
        <li>Registro Cs: el dos almacena la dirección inicial del segmento de código de un
          programa en el registro CS. Indica la dirección de una instrucción que es buscada
          para su ejecución.</li>
        <li>Registro Ds: genera una referencia a la localidad de un byte específico en el
          segmento de datos.
        </li>
        <li>Registro SS: permite la colocación en memoria de una pila, para almacenamiento
          temporal de dirección y datos.</li>
        <li>Registro ES: se utiliza para algunas operaciones con cadenas de caracteres se
          utiliza para el manejo de direccionamiento de memoria.</li>
      </ul>
      </p>
      <p class="has-text-justified py-2">
        <strong>Registros de propósito general: </strong> Los registros de propósito general son el AX, BX, CX, y
        DX, de 16 bits. Cada uno de ellos se divide en dos registros de 8 bits, llamados AH y AL,
        BH y BL, CH y CL, y, DH y DL, H significando High (alto) y L significando Low (bajo),
        indicando la parte alta o la parte baja del registro correspondiente de 16 bits.
      </p>
      <p class="has-text-justified py-2">
        Registro AX: El registro AX es el registro acumulador, es utilizado para
        operaciones que implican entrada/salida, y multiplicación y división (estas dos
        últimas en conjunto con el registro DX). </p>
      <p class="has-text-justified py-1">
        • Registro BX: El registro BX es el registro base, y es el único registro de propósito
        general que puede ser un índice para direccionamiento indexado.</p>
      <p class="has-text-justified py-1">
        • Registro CX: El registro CX es conocido como el registro contador. Puede
        contener un valor para controlar el número de veces que un ciclo se repite o un
        valor para corrimiento de bits.</p>
      <p class="has-text-justified py-1">
        • Registro DX: El registro DX es el registro de datos. En algunas operaciones se
        indica mediante este registro el número de puerto de entrada/salida, y en las
        operaciones de multiplicación y división de 16 bits se utiliza junto con el
        acumulador AX. </p>
      <p class="has-text-justified py-2">
        <strong>Registros de apuntadores: </strong> Los registros SP (apuntador de pila) y BP (apuntador base)
        están asociados con el registro SS y permiten al sistema acceder a datos en el segmento
        de la pila.
      </p>
      <p class="has-text-justified py-1">
        • Registro SP: El apuntador de pila de 16 bits está asociado con el segmento SS y
        proporciona un valor de desplazamiento que se refiere a la palabra actual que está
        siendo procesada en la pila.
      </p>
      <p class="has-text-justified py-1">
        • Registro BP: El apuntador base de 16 bits facilita la referencia de parámetros
        dentro de la pila.
      </p>
      <p class="has-text-justified py-2">
        <strong>Registros de banderas: </strong> Es un registro de 16 bits, de los cuales nueve sirven para indicar
        el estado actual de la máquina y el resultado del procesamiento.
        de la pila.
      </p>
      <div class="block has-text-justified">
        La tabla contiene 16 posiciones (de 0 a 15), que son los 16 bits del registro de banderas,
        numeradas de derecha a izquierda. La posición 0 la encontraremos a la derecha y la
        posición 15 a la izquierda.</div>
      <div class="has-text-justified">
        Los bits de las banderas son las siguientes:
      </div>


      <h5 class="subtitle is-5 has-text-left">
        Modelo Harvard
      </h5>
      <p class="has-text-justified py-2">
        El tamaño de las instrucciones no está relacionado con el de
        los datos, y por lo tanto puede ser optimizado para que
        cualquier instrucción ocupe una sola posición de memoria de
        programa, logrando así mayor velocidad y menor longitud de
        programa.
        El tiempo de acceso a las instrucciones puede superponerse
        con el de los datos, logrando una mayor velocidad en cada
        operación.
        La principal desventaja de esta arquitectura; el bus de datos
        y direcciones único se convierte en un cuello de botella por
        el cual debe pasar toda la información que se lee de o se
        escribe a la memoria, obligando a que todos los accesos a
        esta sean secuenciales.
        Limita el grado de paralelismo (acciones que se pueden
        realizar al mismo tiempo) y por lo tanto, el desempeño de la
        computadora. </p>
      <h5 class="subtitle is-5 has-text-left">
        1.1.2 Segmentadas
      </h5>
      <p class="has-text-justified py-2">
        Es una de las tecnologías utilizadas para realizar la
        segmentación o paralelismo. Divide el procesador, en etapas,
        procesa una instrucción diferente en cada una y trabaja con
        varias a la vez.
      <p class="has-text-justified py-1">
        Pueden trabajar de forma paralela, en diferentes
        instrucciones, utilizando una cola de instrucciones para su
        comunicación, denominado entubamiento.</p>
      <p class="has-text-justified py-1">
        La dependencia de datos y de control, que tiene como efecto
        la disminución del rendimiento del pipelining.
        La segmentación de cauce (pipelining) es una forma efectiva
        de organizar el hardware del CPU para realizar más de una
        operación al mismo tiempo.</p>
      <p class="has-text-justified py-1">
        Consiste en descomponer el proceso de ejecución de las
        instrucciones en fases o etapas que permitan una ejecución
        simultánea.</p>
      <p class="has-text-justified py-1">
        Explota el paralelismo entre las instrucciones de un flujo
        secuencial.</p>
      <p class="has-text-justified py-1">
        La segmentación es una técnica de implementación por la
        cual se solapa la ejecución de múltiples instrucciones.
        La técnica de implementación clave utilizada para hacer
        CPU rápidas.</p>
      <p class="has-text-justified py-1">
        La segmentación es como una línea de ensamblaje: cada
        etapa de la segmentación completa una parte de la
        instrucción.</p>
      <p class="has-text-justified py-1">
        Como en una línea de ensamblaje, la acción a realizar en una
        instrucción se descompone en partes más pequeñas, cada una
        de las cuales necesita una fracción del tiempo necesario para
        completar la instrucción completa.
        Cada uno de estos pasos se define como etapa de la
        segmentación o segmento.</p>
      <p class="has-text-justified py-1">
        Las etapas están conectadas, cada una a la siguiente, para
        formar una especie de cauce las instrucciones se entran por
        un extremo, son procesadas a través de las etapas y salen por
        el otro.</p>
      <p class="has-text-justified py-1">
        La productividad de la segmentación está determinada por la
        frecuencia con que una instrucción salga del cauce.
        Como las etapas están conectadas entre sí, todas las etapas
        deben estar listas para proceder al mismo tiempo. El tiempo
        requerido para desplazar una instrucción, un paso, a lo largo
        del cauce es un ciclo máquina.</p>
      <p class="has-text-justified py-1">
        La duración de un ciclo máquina está determinada por el
        tiempo que necesita la etapa más lenta (porque todas las
        etapas progresan a la vez).</p>
      <p class="has-text-justified py-1">
        Con frecuencia, el ciclo máquina es un ciclo de reloj (a veces
        dos, o raramente más), aunque el reloj puede tener múltiples
        fases.</p>
      <p class="has-text-justified py-1">
        La mejora de velocidad debida a la segmentación es igual al
        número de etapas.</p>
      <p class="has-text-justified py-1">
        La segmentación consigue una reducción en el tiempo de
        ejecución medio por instrucción.
        Esta reducción se puede obtener decrementando la duración
        del ciclo de reloj de la máquina segmentada o disminuyendo
        el número de ciclos de reloj por instrucción, o haciendo
        ambas cosas.</p>
      <p class="has-text-justified py-1">
        El mayor impacto está en el número de ciclos de reloj por
        instrucción, aunque el ciclo de reloj es, con frecuencia, más
        corto en una máquina segmentada (especialmente en
        supercomputadores segmentados).</p>
      <p class="has-text-justified py-1">
        La segmentación es una técnica de implementación, que
        explota el paralelismo entre las instrucciones de un flujo
        secuencial. Tiene la ventaja sustancial que, de forma distinta
        a algunas técnicas de aumento de velocidad, no es visible al
        programador.
      </p>
    </div>

  </section>

  <footer class="footer has-background-dark py-6">
    <div class="has-text-centered">
      <p class="has-text-white">
        Sitio realizado por <strong class="has-text-white">Josué David Hernández González</strong>
      </p>
    </div>
  </footer>
  <script src="index.js"></script>
</body>

</html>