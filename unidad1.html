<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Unidad 1</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css">
</head>

<body>
  <section>
    <nav class="navbar has-shadow" role="navigation" aria-label="main navigation">
      <div class="navbar-brand">


        <a role="button" class="navbar-burger" aria-label="menu" aria-expanded="false" data-target="navbarBasicExample"
          id="burger">
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
        </a>
      </div>

      <div id="navbarBasicExample" class="navbar-menu">
        <div class="navbar-start">
          <a class="navbar-item " href="index.html">
            Inicio
          </a>

          <div class="navbar-item has-dropdown is-hoverable has-text-grey">
            <a class="navbar-link">
              Unidades
            </a>
            <div class="navbar-dropdown">
              <a class="navbar-item" href="unidad1.html">
                Unidad 1
              </a>
              <a class="navbar-item" href="unidad2.html">
                Unidad 2
              </a>
              <a class="navbar-item" href="unidad3.html">
                Unidad 3
              </a>
              <a class="navbar-item" href="unidad4.html">
                Unidad 4
              </a>
            </div>
          </div>

          <div class="navbar-item has-dropdown is-hoverable">
            <a class="navbar-link">
              Prácticas
            </a>
            <div class="navbar-dropdown">
              <a class="navbar-item" href="/docs/JDHG - PRÁCTICA 1.pdf" target="_blank">
                Práctica 1
              </a>
              <a class="navbar-item" href="/docs/JDHG - PRÁCTICA 2.pdf" target="_blank">
                Práctica 2
              </a>
              <a class="navbar-item" href="/docs/JDHG - PRÁCTICA 3.pdf" target="_blank">
                Práctica 3
              </a>
              <a class="navbar-item" href="/docs/JDHG - PRÁCTICA 4.pdf" target="_blank">
                Práctica 4
              </a>
            </div>
          </div>
        </div>

        <div class="navbar-end">
          <div class="navbar-item">
            <div class="buttons">
              <a class="button is-dark" href="https://github.com/wrongcowboy" target="_blank">
                <strong>Github</strong>
              </a>
              <a class="button is-info" href="https://saltillo.tecnm.mx/" target="_blank">
                <strong>Sitio ITS</strong>
              </a>
            </div>
          </div>
        </div>
      </div>
    </nav>
  </section>

  <section class="is-medium">

    <div class="container has-shadow has-text-centered py-1">
      <h3 class="title is-3">Unidad 1. Arquitectura de Cómputo</h3>
      <h5 class="subtitle is-5 has-text-left">1.1 Modelos de arquitecturas de cómputo</h5>
      <p class="has has-text-justified">Arquitectura de computadoras. Es el diseño y la
        organización de un sistema para un equipo de cómputo.
        Es un modelo y descripción de cada función, así como los
        requerimientos y las implementaciones de diseño para varias
        partes del equipo de cómputo.
        Principalmente enfocamos en la Unidad Central de
        Procesamiento lo conocemos como (CPU) el cual trabaja
        internamente y accede a las direcciones de memoria y a los
        sistemas de entrada salida, periféricos.
        También suele definirse como la selección e interconexión
        de los componentes de hardware para crear computadoras
        según los requerimientos de funcionalidad, rendimiento y
        costo.
        El equipo de cómputo recibe y envía la información a través
        de los periféricos por medio de los canales de distribución o
        buses (cableado físico de interconexión).
        El CPU se encarga de procesar la información que le llega al
        equipo de cómputo.
        El intercambio de información se tiene que hacer con los
        periféricos y el CPU.
        Todas aquellas unidades de un sistema exceptuando el CPU
        se denomina periférico, por lo que el equipo de cómputo
        tiene dos partes bien diferenciadas, que son: el CPU (se
        encarga de ejecutar programas y que está compuesta por la
        memoria principal, la (ALU) Unidad Aritmética Lógica y la
        (UC) unidad de control) y los periféricos (que pueden ser de
        entrada, salida, entrada-salida y las interconexiones).</p>


      <h5 class="subtitle is-5 has-text-left">
        1.1.1 Clásicas
      </h5>
      <p class="has-text-justified py-2">
        Estas arquitecturas se desarrollaron en las primeras
        computadoras electromecánicas y de tubos de vacío.
        Hay dos arquitecturas distintas relacionadas con el uso y
        distribución de la memoria: Arquitectura de Jonh Von
        Neumman y Arquitectura Harvard
      </p>
      <h5 class="subtitle is-5 has-text-left">
        Arquitectura Von Neumann
      </h5>
      <p class="has-text-justified py-2">
        Tradicionalmente los sistemas con microprocesadores se
        basan en esta arquitectura, en la cual la unidad central de
        proceso (CPU), está conectada a una memoria principal
        única (casi siempre sólo RAM) donde se guardan las
        instrucciones del programa y los datos. A dicha memoria se
        accede a través de un sistema interconexión de buses único
        (control, direcciones y datos).
        En un sistema con arquitectura Von Neumann el tamaño de
        la unidad de datos o instrucciones está fijado por el ancho
        del bus que comunica la memoria con la CPU. Así un
        microprocesador de 8 bits con un bus de 8 bits, tendrá que
        manejar datos e instrucciones de una o más unidades de 8
        bits (bytes) de longitud.
        Si tiene que acceder a una instrucción o dato de más de un
        byte de longitud, tendrá que realizar más de un acceso a la
        memoria.
        El tener un único bus hace que el microprocesador sea más
        lento en su respuesta, ya que no puede buscar en memoria
        una nueva instrucción mientras no finalicen las
        transferencias de datos de la instrucción anterior.
      </p>
      <p class="has-text-justified py-2">
        Las computadoras digitales convencionales presentan un
        aspecto Von Neumann. Este modelo consta de cinco
        componentes principales:
      </p>
      <p class="has-text-justified py-2">Unidad de Memoria.</p>
      <p class="has-text-justified py-2">Unidad de Entrada/Salida.</p>
      <p class="has-text-justified py-2">Unidad de Control. (Incluidos CPU)</p>
      <p class="has-text-justified py-2">Unidad Aritmética Lógica. (Incluida en CPU)</p>
      <p class="has-text-justified py-2">Registros de Programas. (Incluidos en CPU)</p>
      <h5 class="subtitle is-5 has-text-left">
        Modelo Von Neumann
      </h5>
      <p class="has-text-justified py-2">
        Las instrucciones provenientes del sistema de entrada, son
        almacenados por la memoria, procesados por la ALU bajo la
        dirección de la unidad de control. Los resultados obtenidos
        son enviados a la unidad de salida.
        El programa almacenado es lo más importante en el modelo.
        Los programas se almacenan en la memoria del equipo junto
        con los datos a procesar.
        En las computadoras de programa almacenado, el programa
        puede manipularse como si se tratara de datos. Este concepto
        da origen a los compiladores, sistemas operativos y es la
        base de la gran versatilidad de las computadoras modernas.</p>
      <h5 class="subtitle is-5 has-text-left">
        Limitaciones Von Neumann
      </h5>
      <p class="has-text-justified py-2">
        La longitud de las instrucciones por el bus de datos, que hace
        que el microprocesador tenga que realizar varios accesos a
        memoria para buscar instrucciones complejas.
        La velocidad de operación a causa del bus único para datos e
        instrucciones que no deja acceder simultáneamente a unos y
        otras, lo cual impide superponer ambos tiempos de acceso.
      </p>

      <h5 class="subtitle is-5 has-text-left">
        Modelo Harvard
      </h5>
      <p class="has-text-justified py-2">
        Esta arquitectura utiliza los Micro controladores, tiene la
        unidad central de proceso (CPU) conectada a dos memorias
        (una con las instrucciones y otra con los datos) por medio de
        dos buses diferentes.</p>
      <p class="has-text-justified py-2">
        Una de las memorias contiene solamente las instrucciones
        del programa (Memoria de Programa), y la otra sólo
        almacena datos (Memoria de Datos).
        Ambos buses son totalmente independientes lo que permite
        que la CPU pueda acceder de forma independiente y
        simultánea a la memoria de datos y a la de instrucciones.
        Como los buses son independientes estos pueden tener
        distintos contenidos en la misma dirección y también distinta
        longitud. </p>
      <p class="has-text-justified py-2">
        También la longitud de los datos y las instrucciones puede
        ser distinta, lo que optimiza el uso de la memoria en general.
        Para un procesador de Set de Instrucciones Reducido, o
        RISC (Reduced Instrucción Set Computer), el set de
        instrucciones y el bus de memoria de programa pueden
        diseñarse de tal manera que todas las instrucciones tengan
        una sola posición de memoria de programa de longitud.
        Además, al ser los buses independientes, el CPU puede
        acceder a los datos para completar la ejecución de una
        instrucción, y al mismo tiempo leer la siguiente instrucción a
        ejecutar. </p>
      <h5 class="subtitle is-5 has-text-left">
        Modelo Harvard
      </h5>
      <p class="has-text-justified py-2">
        El tamaño de las instrucciones no está relacionado con el de
        los datos, y por lo tanto puede ser optimizado para que
        cualquier instrucción ocupe una sola posición de memoria de
        programa, logrando así mayor velocidad y menor longitud de
        programa.
        El tiempo de acceso a las instrucciones puede superponerse
        con el de los datos, logrando una mayor velocidad en cada
        operación.
        La principal desventaja de esta arquitectura; el bus de datos
        y direcciones único se convierte en un cuello de botella por
        el cual debe pasar toda la información que se lee de o se
        escribe a la memoria, obligando a que todos los accesos a
        esta sean secuenciales.
        Limita el grado de paralelismo (acciones que se pueden
        realizar al mismo tiempo) y por lo tanto, el desempeño de la
        computadora. </p>
      <h5 class="subtitle is-5 has-text-left">
        1.1.2 Segmentadas
      </h5>
      <p class="has-text-justified py-2">
        Es una de las tecnologías utilizadas para realizar la
        segmentación o paralelismo. Divide el procesador, en etapas,
        procesa una instrucción diferente en cada una y trabaja con
        varias a la vez.
      <p class="has-text-justified py-1">
        Pueden trabajar de forma paralela, en diferentes
        instrucciones, utilizando una cola de instrucciones para su
        comunicación, denominado entubamiento.</p>
      <p class="has-text-justified py-1">
        La dependencia de datos y de control, que tiene como efecto
        la disminución del rendimiento del pipelining.
        La segmentación de cauce (pipelining) es una forma efectiva
        de organizar el hardware del CPU para realizar más de una
        operación al mismo tiempo.</p>
      <p class="has-text-justified py-1">
        Consiste en descomponer el proceso de ejecución de las
        instrucciones en fases o etapas que permitan una ejecución
        simultánea.</p>
      <p class="has-text-justified py-1">
        Explota el paralelismo entre las instrucciones de un flujo
        secuencial.</p>
      <p class="has-text-justified py-1">
        La segmentación es una técnica de implementación por la
        cual se solapa la ejecución de múltiples instrucciones.
        La técnica de implementación clave utilizada para hacer
        CPU rápidas.</p>
      <p class="has-text-justified py-1">
        La segmentación es como una línea de ensamblaje: cada
        etapa de la segmentación completa una parte de la
        instrucción.</p>
      <p class="has-text-justified py-1">
        Como en una línea de ensamblaje, la acción a realizar en una
        instrucción se descompone en partes más pequeñas, cada una
        de las cuales necesita una fracción del tiempo necesario para
        completar la instrucción completa.
        Cada uno de estos pasos se define como etapa de la
        segmentación o segmento.</p>
      <p class="has-text-justified py-1">
        Las etapas están conectadas, cada una a la siguiente, para
        formar una especie de cauce las instrucciones se entran por
        un extremo, son procesadas a través de las etapas y salen por
        el otro.</p>
      <p class="has-text-justified py-1">
        La productividad de la segmentación está determinada por la
        frecuencia con que una instrucción salga del cauce.
        Como las etapas están conectadas entre sí, todas las etapas
        deben estar listas para proceder al mismo tiempo. El tiempo
        requerido para desplazar una instrucción, un paso, a lo largo
        del cauce es un ciclo máquina.</p>
      <p class="has-text-justified py-1">
        La duración de un ciclo máquina está determinada por el
        tiempo que necesita la etapa más lenta (porque todas las
        etapas progresan a la vez).</p>
      <p class="has-text-justified py-1">
        Con frecuencia, el ciclo máquina es un ciclo de reloj (a veces
        dos, o raramente más), aunque el reloj puede tener múltiples
        fases.</p>
      <p class="has-text-justified py-1">
        La mejora de velocidad debida a la segmentación es igual al
        número de etapas.</p>
      <p class="has-text-justified py-1">
        La segmentación consigue una reducción en el tiempo de
        ejecución medio por instrucción.
        Esta reducción se puede obtener decrementando la duración
        del ciclo de reloj de la máquina segmentada o disminuyendo
        el número de ciclos de reloj por instrucción, o haciendo
        ambas cosas.</p>
      <p class="has-text-justified py-1">
        El mayor impacto está en el número de ciclos de reloj por
        instrucción, aunque el ciclo de reloj es, con frecuencia, más
        corto en una máquina segmentada (especialmente en
        supercomputadores segmentados).</p>
      <p class="has-text-justified py-1">
        La segmentación es una técnica de implementación, que
        explota el paralelismo entre las instrucciones de un flujo
        secuencial. Tiene la ventaja sustancial que, de forma distinta
        a algunas técnicas de aumento de velocidad, no es visible al
        programador.
      </p>
    </div>

  </section>

  <footer class="footer has-background-dark py-6">
    <div class="has-text-centered">
      <p class="has-text-white">
        Sitio realizado por <strong class="has-text-white">Josué David Hernández González</strong>
      </p>
    </div>
  </footer>
  <script src="index.js"></script>
</body>

</html>