<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Unidad 1</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css">
</head>

<body>
  <section>
    <nav class="navbar has-shadow" role="navigation" aria-label="main navigation">
      <div class="navbar-brand">


        <a role="button" class="navbar-burger" aria-label="menu" aria-expanded="false" data-target="navbarBasicExample"
          id="burger">
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
        </a>
      </div>

      <div id="navbarBasicExample" class="navbar-menu">
        <div class="navbar-start">
          <a class="navbar-item " href="index.html">
            Inicio
          </a>

          <div class="navbar-item has-dropdown is-hoverable has-text-grey">
            <a class="navbar-link">
              Unidades
            </a>
            <div class="navbar-dropdown">
              <a class="navbar-item" href="unidad1.html">
                Unidad 1
              </a>
              <a class="navbar-item" href="unidad2.html">
                Unidad 2
              </a>
              <a class="navbar-item" href="unidad3.html">
                Unidad 3
              </a>
              <a class="navbar-item" href="unidad4.html">
                Unidad 4
              </a>
            </div>
          </div>

          <div class="navbar-item has-dropdown is-hoverable">
            <a class="navbar-link">
              Prácticas
            </a>
            <div class="navbar-dropdown">
              <a class="navbar-item" href="/docs/JDHG - PRÁCTICA 1.pdf" target="_blank">
                Práctica 1
              </a>
              <a class="navbar-item" href="/docs/JDHG - PRÁCTICA 2.pdf" target="_blank">
                Práctica 2
              </a>
              <a class="navbar-item" href="/docs/JDHG - PRÁCTICA 3.pdf" target="_blank">
                Práctica 3
              </a>
              <a class="navbar-item" href="/docs/JDHG - PRÁCTICA 4.pdf" target="_blank">
                Práctica 4
              </a>
            </div>
          </div>
        </div>

        <div class="navbar-end">
          <div class="navbar-item">
            <div class="buttons">
              <a class="button is-dark" href="https://github.com/wrongcowboy" target="_blank">
                <strong>Github</strong>
              </a>
              <a class="button is-info" href="https://saltillo.tecnm.mx/" target="_blank">
                <strong>Sitio ITS</strong>
              </a>
            </div>
          </div>
        </div>
      </div>
    </nav>
  </section>

  <section class="is-large">

    <div class="container has-shadow has-text-centered py-1">
      <h3 class="title is-3">Unidad 1. Arquitectura de Cómputo</h3>
      <h5 class="subtitle is-5 has-text-left"><strong>1.1 Modelos de arquitecturas de cómputo</strong></h5>
      <p class="has has-text-justified">
        Arquitectura de computadoras. Es el diseño y la
        organización de un sistema para un equipo de cómputo.
        Es un modelo y descripción de cada función, así como los
        requerimientos y las implementaciones de diseño para varias
        partes del equipo de cómputo.
        Principalmente enfocamos en la Unidad Central de
        Procesamiento lo conocemos como (CPU) el cual trabaja
        internamente y accede a las direcciones de memoria y a los
        sistemas de entrada salida, periféricos.
        También suele definirse como la selección e interconexión
        de los componentes de hardware para crear computadoras
        según los requerimientos de funcionalidad, rendimiento y
        costo.
        El equipo de cómputo recibe y envía la información a través
        de los periféricos por medio de los canales de distribución o
        buses (cableado físico de interconexión).
        El CPU se encarga de procesar la información que le llega al
        equipo de cómputo.
        El intercambio de información se tiene que hacer con los
        periféricos y el CPU.
        Todas aquellas unidades de un sistema exceptuando el CPU
        se denomina periférico, por lo que el equipo de cómputo
        tiene dos partes bien diferenciadas, que son: el CPU (se
        encarga de ejecutar programas y que está compuesta por la
        memoria principal, la (ALU) Unidad Aritmética Lógica y la
        (UC) unidad de control) y los periféricos (que pueden ser de
        entrada, salida, entrada-salida y las interconexiones).</p>


      <h5 class="subtitle is-5 has-text-left">
        <strong>1.1.1 Clásicas</strong>
      </h5>
      <p class="has-text-justified py-2">
        Estas arquitecturas se desarrollaron en las primeras
        computadoras electromecánicas y de tubos de vacío.
        Hay dos arquitecturas distintas relacionadas con el uso y
        distribución de la memoria: Arquitectura de Jonh Von
        Neumman y Arquitectura Harvard
      </p>
      <h5 class="subtitle is-5 has-text-left">
        Arquitectura Von Neumann
      </h5>
      <p class="has-text-justified py-2">
        Tradicionalmente los sistemas con microprocesadores se
        basan en esta arquitectura, en la cual la unidad central de
        proceso (CPU), está conectada a una memoria principal
        única (casi siempre sólo RAM) donde se guardan las
        instrucciones del programa y los datos. A dicha memoria se
        accede a través de un sistema interconexión de buses único
        (control, direcciones y datos).
        En un sistema con arquitectura Von Neumann el tamaño de
        la unidad de datos o instrucciones está fijado por el ancho
        del bus que comunica la memoria con la CPU. Así un
        microprocesador de 8 bits con un bus de 8 bits, tendrá que
        manejar datos e instrucciones de una o más unidades de 8
        bits (bytes) de longitud.
        Si tiene que acceder a una instrucción o dato de más de un
        byte de longitud, tendrá que realizar más de un acceso a la
        memoria.
        El tener un único bus hace que el microprocesador sea más
        lento en su respuesta, ya que no puede buscar en memoria
        una nueva instrucción mientras no finalicen las
        transferencias de datos de la instrucción anterior.
      </p>
      <p class="has-text-justified py-2">
        Las computadoras digitales convencionales presentan un
        aspecto Von Neumann. Este modelo consta de cinco
        componentes principales:
      </p>
      <p class="has-text-justified py-2">Unidad de Memoria.</p>
      <p class="has-text-justified py-2">Unidad de Entrada/Salida.</p>
      <p class="has-text-justified py-2">Unidad de Control. (Incluidos CPU)</p>
      <p class="has-text-justified py-2">Unidad Aritmética Lógica. (Incluida en CPU)</p>
      <p class="has-text-justified py-2">Registros de Programas. (Incluidos en CPU)</p>
      <h5 class="subtitle is-5 has-text-left">
        Modelo Von Neumann
      </h5>
      <p class="has-text-justified py-2">
        Las instrucciones provenientes del sistema de entrada, son
        almacenados por la memoria, procesados por la ALU bajo la
        dirección de la unidad de control. Los resultados obtenidos
        son enviados a la unidad de salida.
        El programa almacenado es lo más importante en el modelo.
        Los programas se almacenan en la memoria del equipo junto
        con los datos a procesar.
        En las computadoras de programa almacenado, el programa
        puede manipularse como si se tratara de datos. Este concepto
        da origen a los compiladores, sistemas operativos y es la
        base de la gran versatilidad de las computadoras modernas.</p>
      <h5 class="subtitle is-5 has-text-left">
        Limitaciones Von Neumann
      </h5>
      <p class="has-text-justified py-2">
        La longitud de las instrucciones por el bus de datos, que hace
        que el microprocesador tenga que realizar varios accesos a
        memoria para buscar instrucciones complejas.
        La velocidad de operación a causa del bus único para datos e
        instrucciones que no deja acceder simultáneamente a unos y
        otras, lo cual impide superponer ambos tiempos de acceso.
      </p>

      <h5 class="subtitle is-5 has-text-left">
        Modelo Harvard
      </h5>
      <p class="has-text-justified py-2">
        Esta arquitectura utiliza los Micro controladores, tiene la
        unidad central de proceso (CPU) conectada a dos memorias
        (una con las instrucciones y otra con los datos) por medio de
        dos buses diferentes.</p>
      <p class="has-text-justified py-2">
        Una de las memorias contiene solamente las instrucciones
        del programa (Memoria de Programa), y la otra sólo
        almacena datos (Memoria de Datos).
        Ambos buses son totalmente independientes lo que permite
        que la CPU pueda acceder de forma independiente y
        simultánea a la memoria de datos y a la de instrucciones.
        Como los buses son independientes estos pueden tener
        distintos contenidos en la misma dirección y también distinta
        longitud. </p>
      <p class="has-text-justified py-2">
        También la longitud de los datos y las instrucciones puede
        ser distinta, lo que optimiza el uso de la memoria en general.
        Para un procesador de Set de Instrucciones Reducido, o
        RISC (Reduced Instrucción Set Computer), el set de
        instrucciones y el bus de memoria de programa pueden
        diseñarse de tal manera que todas las instrucciones tengan
        una sola posición de memoria de programa de longitud.
        Además, al ser los buses independientes, el CPU puede
        acceder a los datos para completar la ejecución de una
        instrucción, y al mismo tiempo leer la siguiente instrucción a
        ejecutar. </p>
      <h5 class="subtitle is-5 has-text-left">
        Modelo Harvard
      </h5>
      <p class="has-text-justified py-2">
        El tamaño de las instrucciones no está relacionado con el de
        los datos, y por lo tanto puede ser optimizado para que
        cualquier instrucción ocupe una sola posición de memoria de
        programa, logrando así mayor velocidad y menor longitud de
        programa.
        El tiempo de acceso a las instrucciones puede superponerse
        con el de los datos, logrando una mayor velocidad en cada
        operación.
        La principal desventaja de esta arquitectura; el bus de datos
        y direcciones único se convierte en un cuello de botella por
        el cual debe pasar toda la información que se lee de o se
        escribe a la memoria, obligando a que todos los accesos a
        esta sean secuenciales.
        Limita el grado de paralelismo (acciones que se pueden
        realizar al mismo tiempo) y por lo tanto, el desempeño de la
        computadora. </p>
      <h5 class="subtitle is-5 has-text-left">
        <strong>1.1.2 Segmentadas</strong>
      </h5>
      <p class="has-text-justified py-2">
        Es una de las tecnologías utilizadas para realizar la
        segmentación o paralelismo. Divide el procesador, en etapas,
        procesa una instrucción diferente en cada una y trabaja con
        varias a la vez.
      <p class="has-text-justified py-1">
        Pueden trabajar de forma paralela, en diferentes
        instrucciones, utilizando una cola de instrucciones para su
        comunicación, denominado entubamiento.</p>
      <p class="has-text-justified py-1">
        La dependencia de datos y de control, que tiene como efecto
        la disminución del rendimiento del pipelining.
        La segmentación de cauce (pipelining) es una forma efectiva
        de organizar el hardware del CPU para realizar más de una
        operación al mismo tiempo.</p>
      <p class="has-text-justified py-1">
        Consiste en descomponer el proceso de ejecución de las
        instrucciones en fases o etapas que permitan una ejecución
        simultánea.</p>
      <p class="has-text-justified py-1">
        Explota el paralelismo entre las instrucciones de un flujo
        secuencial.</p>
      <p class="has-text-justified py-1">
        La segmentación es una técnica de implementación por la
        cual se solapa la ejecución de múltiples instrucciones.
        La técnica de implementación clave utilizada para hacer
        CPU rápidas.</p>
      <p class="has-text-justified py-1">
        La segmentación es como una línea de ensamblaje: cada
        etapa de la segmentación completa una parte de la
        instrucción.</p>
      <p class="has-text-justified py-1">
        Como en una línea de ensamblaje, la acción a realizar en una
        instrucción se descompone en partes más pequeñas, cada una
        de las cuales necesita una fracción del tiempo necesario para
        completar la instrucción completa.
        Cada uno de estos pasos se define como etapa de la
        segmentación o segmento.</p>
      <p class="has-text-justified py-1">
        Las etapas están conectadas, cada una a la siguiente, para
        formar una especie de cauce las instrucciones se entran por
        un extremo, son procesadas a través de las etapas y salen por
        el otro.</p>
      <p class="has-text-justified py-1">
        La productividad de la segmentación está determinada por la
        frecuencia con que una instrucción salga del cauce.
        Como las etapas están conectadas entre sí, todas las etapas
        deben estar listas para proceder al mismo tiempo. El tiempo
        requerido para desplazar una instrucción, un paso, a lo largo
        del cauce es un ciclo máquina.</p>
      <p class="has-text-justified py-1">
        La duración de un ciclo máquina está determinada por el
        tiempo que necesita la etapa más lenta (porque todas las
        etapas progresan a la vez).</p>
      <p class="has-text-justified py-1">
        Con frecuencia, el ciclo máquina es un ciclo de reloj (a veces
        dos, o raramente más), aunque el reloj puede tener múltiples
        fases.</p>
      <p class="has-text-justified py-1">
        La mejora de velocidad debida a la segmentación es igual al
        número de etapas.</p>
      <p class="has-text-justified py-1">
        La segmentación consigue una reducción en el tiempo de
        ejecución medio por instrucción.
        Esta reducción se puede obtener decrementando la duración
        del ciclo de reloj de la máquina segmentada o disminuyendo
        el número de ciclos de reloj por instrucción, o haciendo
        ambas cosas.</p>
      <p class="has-text-justified py-1">
        El mayor impacto está en el número de ciclos de reloj por
        instrucción, aunque el ciclo de reloj es, con frecuencia, más
        corto en una máquina segmentada (especialmente en
        supercomputadores segmentados).</p>
      <p class="has-text-justified py-1">
        La segmentación es una técnica de implementación, que
        explota el paralelismo entre las instrucciones de un flujo
        secuencial. Tiene la ventaja sustancial que, de forma distinta
        a algunas técnicas de aumento de velocidad, no es visible al
        programador.
      </p>
      <p class="has-text-justified py-1">
        <strong>Tipos de cauces:</strong>
      </p>
      <p class="has-text-justified py-1">
        <strong>Unifunción:</strong> ejecutan un único proceso.
      </p>
      <p class="has-text-justified py-1">
        <strong>Multifunción:</strong> pueden ejecutar varios procesos:
      </p>
      <ol class="has-text-justified py-1">
        <li><strong>Estáticos:</strong> en un instante determinado sólo pueden ejecutar
          uno.</li>
        <li><strong>Dinámicos:</strong> pueden ejecutar simultáneamente varios
          procesos.</li>
        <li><strong>Lineal:</strong> a cada etapa sólo le puede seguir otra etapa concreta.</li>
        <li><strong>No lineal:</strong> se pueden establecer recorridos complejos de
          las etapas.</li>
      </ol>
      <p class="has-text-justified py-1">
        Ciclos de Instrucción.
      </p>
      <p class="has-text-justified py-1">
        Ejecución de instrucciones en 5 ciclos.
      </p>
      <p class="has-text-justified py-1">
        Etapas de cauce.
      </p>
      <p class="has-text-justified py-1">
        Donde:
      <p class="has-text-justified py-1">
        <strong>IF:</strong> Búsqueda de una instrucción de la memoria.
      </p>
      <p class="has-text-justified py-1">
        <strong>ID:</strong> Búsqueda de registros y decodificación de instrucciones.
      </p>
      <p class="has-text-justified py-1">
        <strong>EXE:</strong> Ejecución o cálculo de dirección.
      </p>
      <p class="has-text-justified py-1">
        <strong>MEM:</strong> Acceso a la memoria de datos.
      </p>
      <p class="has-text-justified py-1">
        <strong>WB:</strong> Escribir datos en el archivo de registros.
      <p class="has-text-justified py-1">
        La segmentación ayuda en la realización de una carga de
        trabajo.
      </p>
      <p class="has-text-justified py-1">
        Realiza múltiples tareas simultáneamente utilizando
        diferentes recursos.
      </p>
      <p class="has-text-justified py-1">
        La velocidad se incrementa si se aumenta el número de
        segmentos.
      </p>
      <p class="has-text-justified py-1">
        La razón de segmentación está dada por el segmento más
        lento.
      </p>
      <p class="has-text-justified py-1">
        El tiempo en llenar y vaciar los segmentos reduce la
        velocidad.
      </p>
      <p class="has-text-justified py-1">
        Dedica unidades específicas del procesador a cada una de las
        partes del ciclo de instrucción y ejecutarlas paralelamente.
      </p>
      <p class="has-text-justified py-1">
        Mejora dramáticamente el rendimiento debido a que en los
        procesadores tienen etapas en el ciclo de instrucción.
      </p>
      <p class="has-text-justified py-1">
        La unidad de control se subdivide en dos o más unidades
        funcionales, cada una encargada de llevar a cabo una parte
        del ciclo de instrucción.
      </p>
      <p class="has-text-justified py-1">
        Se comunican a través de una cola de instrucciones
        (Pipeline).
      </p>
      <h5 class="subtitle is-5 has-text-left">
        <strong>1.1.3 Multiprocesamiento</strong>
      </h5>
      <p class="has-text-justified py-1">
        Se denomina multiprocesador a un computador que cuenta
        con dos o más microprocesadores (CPUs).
      </p>
      <p class="has-text-justified py-1">
        El multiprocesador puede ejecutar simultáneamente varios
        hilos pertenecientes a un mismo proceso o bien a procesos
        diferentes.
      </p>
      <p class="has-text-justified py-1">
        La arquitectura NUMA, donde cada procesador tiene acceso
        y control exclusivo a una parte de la memoria.
      </p>
      <p class="has-text-justified py-1">
        La arquitectura SMP, donde todos los procesadores
        comparten toda la memoria.
      </p>
      <p class="has-text-justified py-1">
        Para que un multiprocesador opere correctamente necesita
        un sistema operativo especialmente diseñado para ello.
      </p>
      <p class="has-text-justified py-1">
        La mayoría de los sistemas operativos actuales poseen esta
        capacidad.
      </p>
      <p class="has-text-justified py-1">
        Cuando se desea incrementar el desempeño más de lo que
        permite la técnica de segmentación (pipeline), se requiere
        utilizar más de un procesador para la ejecución del programa
        de aplicación.
      </p>
      <p class="has-text-justified py-1">
        Los CPU de multiprocesamiento según Flynn se clasifican
        de la siguiente manera:
      </p>
      <p class="has-text-justified py-1">
        SISO - (Single Instruction, Single Operand) computadoras
        Monoprocesador
      </p>
      <p class="has-text-justified py-1">
        SIMO - (Single Instruction, Multiple Operand) procesadores
        vectoriales, Exenciones MMX
      </p>
      <p class="has-text-justified py-1">
        MISO - (Multiple Instruction, Single Operand) No
        implementado
      </p>
      <p class="has-text-justified py-1">
        MIMO - (Multiple Instruction, Multiple Operand) sistemas
        SMP, Clusters, GPUs
      </p>
      <p class="has-text-justified py-1">
        Los procesadores vectoriales, son computadoras pensadas
        para aplicar un mismo algoritmo numérico a una serie de
        datos matriciales, en especial en la simulación de sistemas
        físicos complejos, tales como simuladores de clima,
        explosiones atómicas, reacciones químicas, etc.
      </p>
      <p class="has-text-justified py-1">
        Donde los datos son representados como grandes números de
        datos en forma matricial sobre los que se deben se aplicar el
        mismo algoritmo numérico.
      </p>
      <p class="has-text-justified py-1">
        La mayoría de los procesadores modernos incluye algunas
        instrucciones de tipo vectorial, tales como las extensiones al
        conjunto de instrucciones tales como MMX y SSE. Estas
        instrucciones les permiten procesar flujos multimedia más
        eficientemente.
      </p>
      <p class="has-text-justified py-1">
        Los Procesadores Digitales de Señales (DSP), son
        procesadores especializados en el procesamiento de señales
        tales como audio, vídeo, radar, sonar, radio, etc.
      </p>
      <p class="has-text-justified py-1">
        Cuentan con instrucciones tipo vectorial que los hace muy
        aptos para dicha aplicación. Suelen utilizarse en conjunto
        con un microcontrolador en dispositivos como reproductores
        de audio, reproductores de DVD y Blueray, teléfonos
        celulares, sistemas de entretenimiento, sistemas de
        adquisición de datos, instrumentos médicos, controles
        industriales, etc.
      </p>
      <p class="has-text-justified py-1">
        En los sistemas SMP (Simetric Multiprocessing), varios
        procesadores comparten la misma memoria principal y
        periféricos de Entrada /Salida, normalmente conectados por
        un bus común.
      </p>
      <p class="has-text-justified py-1">
        Se conocen como simétricos, ya que ningún procesador toma
        el papel de maestro y los demás de esclavos, sino que todos
        tienen derechos similares en cuanto al acceso a la memoria y
        periféricos y ambos son administrados por el sistema
        operativo.
      </p>
      <p class="has-text-justified py-1">
        Pueden formarse con varios núcleos en un solo circuito
        integrado o con varios circuitos integrados en una misma
        tarjeta madre. La primera opción ha sido popularizada al
        hacerse más económicos los procesadores multinúcleo de los
        principales fabricantes y con su uso en sistemas de gama
        media y baja, e inclusive en teléfonos celulares y tabletas.
      </p>
      <p class="has-text-justified py-1">
        La segunda opción fue la que se uso en un principio y sigue
        siendo usada en en estaciones de trabajo y en servidores de
        alto rendimiento debido a que incrementa el poder
        computacional del sistema, pero también incrementa
        considerablemente el costo del sistema.
      </p>
      <p class="has-text-justified py-1">

      </p>
      <p class="has-text-justified py-1">

      </p>
      <p class="has-text-justified py-1">

      </p>
      <p class="has-text-justified py-1">

      </p>
    </div>
  </section>

  <footer class="footer has-background-dark py-6">
    <div class="has-text-centered">
      <p class="has-text-white">
        Sitio realizado por <strong class="has-text-white">Josué David Hernández González</strong>
      </p>
    </div>
  </footer>
  <script src="index.js"></script>
</body>

</html>